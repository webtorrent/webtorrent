{"version":3,"file":"sw.min.js","mappings":"mBAIA,IAAIA,GAAc,ECAlBC,KAAKC,iBAAiB,WAAW,KAC/BD,KAAKE,aAAY,IAGnBF,KAAKC,iBAAiB,SAASE,IAC7B,MAAMC,EDHSD,KACf,MAAM,IAAEE,GAAQF,EAAMG,QACtB,OAAKD,EAAIE,SAASP,KAAKQ,aAAaC,MAAQ,eACxCJ,EAAIE,SAASP,KAAKQ,aAAaC,MAAQ,yBAAiC,IAAIC,SAC5EL,EAAIE,SAASP,KAAKQ,aAAaC,MAAQ,sBAClC,IAAIC,SAAS,IAAIC,eAAe,CACrCC,SACEb,GAAc,CAChB,KAQNc,gBAAsB,QAAEP,IACtB,MAAM,IAAED,EAAG,OAAES,EAAM,QAAEC,EAAO,YAAEC,GAAgBV,EACxCW,QAAmBC,QAAQC,SAAS,CAAEC,KAAM,SAAUC,qBAAqB,KAE1EC,EAAMC,SAAc,IAAIC,SAAQC,IAErC,IAAK,MAAMC,KAAUT,EAAY,CAC/B,MAAMU,EAAiB,IAAIC,gBACrB,MAAEC,EAAK,MAAEC,GAAUH,EACzBE,EAAME,UAAY,EAAGT,WACnBG,EAAQ,CAACH,EAAMO,GAAM,EAEvBH,EAAOM,YAAY,CACjB3B,MACAS,SACAC,QAASkB,OAAOC,YAAYnB,EAAQoB,WACpC1B,MAAOT,KAAKQ,aAAaC,MACzBO,cACAI,KAAM,cACL,CAACU,GACN,KAGF,IAAIM,EAAU,KACd,MAAMC,EAAU,KACdd,EAAKS,aAAY,GACjBM,aAAaF,GACbb,EAAKQ,UAAY,MAGnB,MAAkB,WAAdT,EAAKiB,MACPF,IACO,IAAI3B,SAASY,EAAKiB,KAAMjB,IAG1B,IAAIZ,SAAS,IAAIC,eAAe,CACrC6B,KAAMC,GACG,IAAIjB,SAAQC,IACjBF,EAAKQ,UAAY,EAAGT,WACdA,EACFmB,EAAWC,QAAQpB,IAEnBe,IACAI,EAAWE,SAEblB,GAAQ,EAEL1B,IAGHuC,aAAaF,GACO,aAAhBpB,IACFoB,EAAUQ,YAAW,KACnBP,IACAZ,GAAQ,GAzEM,OA6EpBF,EAAKS,aAAY,EAAI,IAGzBpB,SACEyB,GACF,IACEf,EACN,CAtESuB,CAAM1C,GATsD,IASjD,ECRN,CAAaA,GACrBC,GAAKD,EAAM2C,YAAY1C,EAAG,IAGhCJ,KAAKC,iBAAiB,YAAY,KAChCD,KAAKkB,QAAQ6B,OAAM,G","sources":["webpack://webtorrent/./lib/worker-server.js","webpack://webtorrent/./lib/worker.js"],"sourcesContent":["/* global clients, MessageChannel, ReadableStream, Response */\r\n/* eslint-env serviceworker */\r\n\r\nconst portTimeoutDuration = 5000\r\nlet cancellable = false\r\n\r\nconst listener = event => {\r\n  const { url } = event.request\r\n  if (!url.includes(self.registration.scope + 'webtorrent/')) return null\r\n  if (url.includes(self.registration.scope + 'webtorrent/keepalive/')) return new Response()\r\n  if (url.includes(self.registration.scope + 'webtorrent/cancel/')) {\r\n    return new Response(new ReadableStream({\r\n      cancel () {\r\n        cancellable = true\r\n      }\r\n    }))\r\n  }\r\n  return serve(event)\r\n}\r\n\r\nexport default listener\r\n\r\nasync function serve ({ request }) {\r\n  const { url, method, headers, destination } = request\r\n  const clientlist = await clients.matchAll({ type: 'window', includeUncontrolled: true })\r\n\r\n  const [data, port] = await new Promise(resolve => {\r\n    // Use race condition for whoever controls the response stream\r\n    for (const client of clientlist) {\r\n      const messageChannel = new MessageChannel()\r\n      const { port1, port2 } = messageChannel\r\n      port1.onmessage = ({ data }) => {\r\n        resolve([data, port1])\r\n      }\r\n      client.postMessage({\r\n        url,\r\n        method,\r\n        headers: Object.fromEntries(headers.entries()),\r\n        scope: self.registration.scope,\r\n        destination,\r\n        type: 'webtorrent'\r\n      }, [port2])\r\n    }\r\n  })\r\n\r\n  let timeOut = null\r\n  const cleanup = () => {\r\n    port.postMessage(false) // send a cancel request\r\n    clearTimeout(timeOut)\r\n    port.onmessage = null\r\n  }\r\n\r\n  if (data.body !== 'STREAM') {\r\n    cleanup()\r\n    return new Response(data.body, data)\r\n  }\r\n\r\n  return new Response(new ReadableStream({\r\n    pull (controller) {\r\n      return new Promise(resolve => {\r\n        port.onmessage = ({ data }) => {\r\n          if (data) {\r\n            controller.enqueue(data) // data is Uint8Array\r\n          } else {\r\n            cleanup()\r\n            controller.close() // data is null, means the stream ended\r\n          }\r\n          resolve()\r\n        }\r\n        if (!cancellable) {\r\n          // firefox doesn't support cancelling of Readable Streams in service workers,\r\n          // so we just empty it after 5s of inactivity, the browser will request another port anyways\r\n          clearTimeout(timeOut)\r\n          if (destination !== 'document') {\r\n            timeOut = setTimeout(() => {\r\n              cleanup()\r\n              resolve()\r\n            }, portTimeoutDuration)\r\n          }\r\n        }\r\n        port.postMessage(true) // send a pull request\r\n      })\r\n    },\r\n    cancel () {\r\n      cleanup()\r\n    }\r\n  }), data)\r\n}\r\n","/* eslint-env serviceworker */\r\n\r\nimport fileResponse from './worker-server.js'\r\n\r\nself.addEventListener('install', () => {\r\n  self.skipWaiting()\r\n})\r\n\r\nself.addEventListener('fetch', event => {\r\n  const res = fileResponse(event)\r\n  if (res) event.respondWith(res)\r\n})\r\n\r\nself.addEventListener('activate', () => {\r\n  self.clients.claim()\r\n})\r\n"],"names":["cancellable","self","addEventListener","skipWaiting","event","res","url","request","includes","registration","scope","Response","ReadableStream","cancel","async","method","headers","destination","clientlist","clients","matchAll","type","includeUncontrolled","data","port","Promise","resolve","client","messageChannel","MessageChannel","port1","port2","onmessage","postMessage","Object","fromEntries","entries","timeOut","cleanup","clearTimeout","body","pull","controller","enqueue","close","setTimeout","serve","respondWith","claim"],"sourceRoot":""}